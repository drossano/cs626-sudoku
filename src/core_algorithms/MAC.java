package core_algorithms;

import csp_problems.CSPProblem;
import csp_problems.Square;

import java.util.*;

/**
 * A generic solver for CSPs that implements the following techniques:
 *   maintaining arc consistency (MAC) +
 *   minimum-remaining-values (MRV)
 * Note: MAC = backtracking search + dynamic arc consistency (AC-3)
 *
 * @param <X> the data type of variables.
 *  *  *     (e.g., for Sudoku, we use Square such as (1, 5) to
 *           name the squares of the 9x9 board, where the first number
 *           specifies the row and the second number specifies the column.)
 * @param <V> the data type of values.
 *     (e.g., in Sudoku, values should be integers between 1 and 9.)
 */
public abstract class MAC<X, V> {

    /**
     * The data type that represents an arc in the AC-3 algorithm.
     * Note that for a record, the equals() and hashCode()
     * methods are automatically generated by Java, making it
     * safe to use a record as a map key.
     * @param head head of the arc
     * @param tail tail of the arc
     * @param <X>
     */
    public  record Arc<X>(X tail, X head){}

    //Maps all variables to their domains.
    private Map<X,List<V>> allVariables;

    //keeps track of the variables that have been assigned so far.
    private final Set<X> assigned;

    private final CSPProblem<X,V> problem;

    public MAC(CSPProblem<X,V> problem){
        this.problem = problem;
        this.allVariables = problem.getAllVariables();
        //populate the assigned set with any pre-assigned variables
        this.assigned = new HashSet<>(problem.getPreAssignedVariables());
    }

    /**
     * Implements the AC-3 (Arc Consistency 3) algorithm.
     *
     * Note that revise() is problem specific and should be individually
     * implement in problem-specific solvers (e.g., MAC_NQueens,
     * BacktrackingSearch_Sudoku.java)
     *
     * @param arcs A queue of arcs that need to be checked for consistency
     * @return false if arc consistency could not be maintained (i.e.,
     * a domain becomes empty),
     *         true otherwise
     *
     * TODO: Implement the AC-3 algorithm by following these steps:
     *  * 1. While there are arcs in the queue:
     *  *    - Remove an arc (tail, head) from the queue.
     *  *    - Call `revise(tail, head)`, which modifies the domain of `tail`
     *  *      if needed.
     *  * 2. If `revise()` reduces the domain of tail:
     *  *    - If `tail`'s domain is empty, return false (inconsistency detected).
     *  *    - Otherwise, add new arcs `(X, tail)` for each neighbor `X` of `tail`
     *  *      (except `head`), while ensuring the queue only contains unique arcs
     *  *      (i.e., no duplicates).
     *  * 3. Continue processing until the queue is empty, then return true.
     *
     *  Important:
     *  * - The queue must only contain unique arcs at any given time.
     *  * - Use an additional data structure to track which arcs are currently in
     *  *   the queue can improve efficiency by reducing redundant checks and
     *  *   avoiding unnecessary reinsertions.
     *
     */
    public boolean AC3(Queue<Arc<X>> arcs){
        do {
            Arc<X> currentArc = arcs.remove();


            if (revise(currentArc.tail, currentArc.head) == true) {
            if (getAllVariables().get(currentArc.tail).size() == 0){
                return false;
            }
            else {
                List<X> neighbors = problem.getNeighborsOf(currentArc.tail);
                neighbors.remove(currentArc.head);

                for (X neighbor : neighbors) {
                    Arc<X> newArc =new Arc<> (neighbor, currentArc.tail);
                    arcs.add(newArc);
                }
            }
                    }
            
        } while (arcs.size() > 0);
        return true;
    }


    /**
     * Performs the AC-3 algorithm as preprocessing before search begins.
     * @return true or false
     */
    public boolean initAC3(){
        Queue<Arc<X>> arcs = new LinkedList<>();
        for(X v : allVariables.keySet()){
            for(X n : problem.getNeighborsOf(v)){
                arcs.add(new Arc<>(n,v));
            }
        }
        return AC3(arcs);
    }

    /**
     * An implementation of the maintaining arc consistency (MAC)
     * algorithm, which is essentially backtracking search plus
     * dynamic arc consistency.
     * @return true if a solution is found
     *         false otherwise
     */
    public boolean search(){
        X n = selectUnassigned();
        if(n == null){
            return true;
        }
        assigned.add(n);
       // System.out.println(n+", "+assigned.size());
        while(!allVariables.get(n).isEmpty()) {
            //select a value to be assigned to this variable
            V value = allVariables.get(n).remove(0);
            //make a deep clone of the nodeList in case
            // we will need to back track later
            Map<X,List<V>> allVariablesClone = deepClone();
            //assign the selected 'value' to the variable n
            allVariables.get(n).clear();
            allVariables.get(n).add(value);
            Queue<Arc<X>> arcs = new LinkedList<>();
            //get all the arcs that could potentially be affected by
            // this assignment, i.e., all the arcs where n is the head.
            for (X nei : problem.getNeighborsOf(n)) {
                arcs.add(new Arc<>(nei, n));
            }
            //Perform initial constraint propagation using the AC-3
            // algorithm before search begins.
            if (AC3(arcs) && search()) {
                return true;
            } else {
                //System.out.println(n+" reverting");
                revert(allVariablesClone);
            }
        }
        assigned.remove(n);
        return false;
    }

    /**
     * Create a deep clone of the allVariables map in case we will need to
     * back track in the future.
     * (Deep clone means to clone every element of the domain list).
     */
    public Map<X,List<V>> deepClone(){
        Map<X,List<V>> allVariablesClone = new HashMap<>();
        for(Map.Entry<X, List<V>> e: allVariables.entrySet()){
            //deep clone the domain list
            allVariablesClone.put(e.getKey(), new ArrayList<>(e.getValue()));
        }
        return allVariablesClone;
    }

    /**
     * Revert the allVariables map to the deep clone copy
     */
    public void revert(Map<X,List<V>> allVariablesClone){
        allVariables = allVariablesClone;
    }

    public Map<X, List<V>> getAllVariables() {
        return allVariables;
    }


    /**
     * Check if the given variable has been assigned a value already.
     * @param var the variable whose assignment will be checked
     * @return true if assigned, false otherwise
     */
    public boolean assigned(X var){
        return assigned.contains(var);
    }


    /**
     * Implements the Minimum Remaining Values (MRV) heuristic.
     *
     * This method is used during backtracking search to decide which unassigned variable
     * to consider next. The MRV heuristic selects the variable with the fewest legal values
     * remaining in its domain, helping reduce the branching factor early in the search.
     *
     * @return the unassigned variable with the smallest domain;
     *         null if all variables have already been assigned.
     *
     * TODO: Implement the MRV heuristic by:
     *  - Iterating through all variables in the problem.
     *  - Skipping any variable that has already been assigned a value.
     *  - Among the unassigned variables, identifying the one with the smallest domain size.
     *  - Returning that variable.
     *
     * Important:
     * - If multiple variables have the same smallest domain size, you may return any one of them.
     * - If all variables are already assigned, return null.
     */
    public X selectUnassigned(){
        X smallestVar = null;
        for (X variable : allVariables.keySet()) {

            if (assigned(variable) == false) {
                if (smallestVar == null) {
                    smallestVar = variable;
                } else if (allVariables.get(variable).size() <= allVariables.get(smallestVar).size() ) {
                    smallestVar = variable;
                }
            }
        }
        return smallestVar;

    }


    //the two abstract methods below should be implemented in BacktrackingSearch_Sudoku.java

    /**
     * revise an arc to maintain arc consistency
     *
     * @param tail tail of the arc
     * @param head head of the arc
     * @return false if no value is deleted, true otherwise
     */
    public abstract boolean revise(X tail, X head);

    /**
     *
     * @return an unassigned variable according to the MRV heuristic;
     *         null if all variables have been assigned
     */
  //  public abstract X selectUnassigned();

}
